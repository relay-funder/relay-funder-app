generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x", "linux-arm64-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
  output        = "../.generated/prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum CampaignStatus {
  DRAFT
  PENDING_APPROVAL
  ACTIVE
  COMPLETED
  FAILED
}

enum PaymentType {
  BUY
  SELL
}

enum RecipientStatus {
  PENDING
  APPROVED
  REJECTED
}

enum Status {
  NOT_STARTED
  ACTIVE
  CLOSED
}

model Campaign {
  id              Int                  @id @default(autoincrement())
  title           String
  description     String
  fundingGoal     String
  startTime       DateTime
  endTime         DateTime
  creatorAddress  String
  status          CampaignStatus       @default(DRAFT)
  transactionHash String?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  campaignAddress String?              @unique
  slug            String               @unique
  location        String?
  treasuryAddress String?
  category        String?
  collections     CampaignCollection[]
  images          CampaignImage[]
  updates         CampaignUpdate[]
  comments        Comment[]
  favorites       Favorite[]
  payments        Payment[]
  RoundCampaigns  RoundCampaigns[]

  @@index([creatorAddress])
  @@index([category])
}

model CampaignImage {
  id          Int      @id @default(autoincrement())
  imageUrl    String
  isMainImage Boolean  @default(false)
  campaignId  Int
  campaign    Campaign @relation(fields: [campaignId], references: [id])
}

model User {
  id                   Int             @id @default(autoincrement())
  address              String          @unique
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt
  prevSigninAt         DateTime?
  lastSigninAt         DateTime?
  lastSignoutAt        DateTime?
  roles                String[]
  crowdsplitCustomerId String?
  email                String?
  username             String?         @unique
  firstName            String?
  lastName             String?
  bio                  String?
  recipientWallet      String?
  isKycCompleted       Boolean?        @default(false)
  collections          Collection[]
  payments             Payment[]
  paymentMethods       PaymentMethod[]
}

model Payment {
  id              Int         @id @default(autoincrement())
  amount          String
  token           String
  status          String      @default("pending")
  type            PaymentType
  transactionHash String?
  isAnonymous     Boolean     @default(false)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  campaignId      Int
  userId          Int
  externalId      String?
  metadata        Json?
  provider        String?
  campaign        Campaign    @relation(fields: [campaignId], references: [id])
  user            User        @relation(fields: [userId], references: [id])

  @@index([campaignId])
  @@index([userId])
  @@index([externalId])
}

model PaymentMethod {
  id         Int      @id @default(autoincrement())
  provider   String
  externalId String
  type       String
  userId     Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([externalId])
}

model Comment {
  id          Int      @id @default(autoincrement())
  content     String
  userAddress String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  campaignId  Int
  campaign    Campaign @relation(fields: [campaignId], references: [id])

  @@index([campaignId])
  @@index([userAddress])
}

model CampaignUpdate {
  id             Int      @id @default(autoincrement())
  title          String
  content        String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  campaignId     Int
  creatorAddress String
  campaign       Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([campaignId])
}

model Round {
  id               Int              @id @default(autoincrement())
  title            String
  description      String
  tags             String[]         @default([])
  matchingPool     Decimal
  applicationStart DateTime
  applicationClose DateTime
  startDate        DateTime
  endDate          DateTime
  blockchain       String
  logoUrl          String?
  createdAt        DateTime         @default(now())
  managerAddress   String
  poolId           BigInt?          @unique
  profileId        String
  strategyAddress  String
  tokenAddress     String
  tokenDecimals    Int
  transactionHash  String?          @unique
  updatedAt        DateTime         @updatedAt
  roundCampaigns   RoundCampaigns[]
}

model RoundCampaigns {
  id                       Int             @id @default(autoincrement())
  roundId                  Int
  campaignId               Int
  reviewedAt               DateTime?
  onchainRecipientId       String?
  recipientAddress         String?
  submittedByWalletAddress String?
  txHash                   String?
  status                   RecipientStatus @default(PENDING)
  Campaign                 Campaign        @relation(fields: [campaignId], references: [id])
  Round                    Round           @relation(fields: [roundId], references: [id])

  @@unique([roundId, campaignId])
}

model Collection {
  id          String               @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  // this should be called userAddress
  userId      String
  campaigns   CampaignCollection[]
  user        User                 @relation(fields: [userId], references: [address])

  @@unique([userId, name])
  @@index([userId])
}

model CampaignCollection {
  campaignId   Int
  collectionId String
  assignedAt   DateTime   @default(now())
  campaign     Campaign   @relation(fields: [campaignId], references: [id])
  collection   Collection @relation(fields: [collectionId], references: [id])

  @@id([campaignId, collectionId])
}

model Favorite {
  id          Int      @id @default(autoincrement())
  userAddress String
  campaignId  Int
  createdAt   DateTime @default(now())
  campaign    Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@unique([userAddress, campaignId])
  @@index([userAddress])
  @@index([campaignId])
}
