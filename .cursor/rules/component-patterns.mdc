---
description: |
  Guidelines and patterns for structuring, organizing, and implementing React components in this project.
globs: []
alwaysApply: true
---

# React Component Patterns

## Component Architecture

### Component Organization
- **UI Components**: Reusable components in [components/ui/](mdc:components/ui/)
- **Feature Components**: Domain-specific components organized by feature
- **Layout Components**: Page structure components in [components/page/](mdc:components/page/)
- **Form Components**: Form-related components with validation

### Component Structure
```typescript
// components/campaign/campaign-card.tsx
import { type Campaign } from '@/types/campaign';
import { Badge, Button } from '@/components/ui';

interface CampaignCardProps {
  campaign: Campaign;
  onFavorite?: (campaignId: number) => void;
  showActions?: boolean;
  className?: string;
}

export function CampaignCard({
  campaign,
  onFavorite,
  showActions = true,
  className
}: CampaignCardProps) {
  return (
    <div className={cn('campaign-card', className)}>
      {/* Component implementation */}
    </div>
  );
}
```

## UI Component Library

### Import Pattern
Always import UI components from the single barrel export:

```typescript
// ✅ Correct - Single import from UI barrel
import { Button, Badge, Card, CardContent, CardHeader, CardTitle } from '@/components/ui';

// ❌ Incorrect - Individual imports
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
```

### Radix UI Integration
The project uses Radix UI components as the foundation for the UI library:

```typescript
// components/ui/button.tsx
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

export function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: ButtonProps) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}
```

### Component Composition
```typescript
// components/campaign/campaign-actions.tsx
import { Button, Badge, Card, CardContent, CardHeader, CardTitle } from '@/components/ui';

export function CampaignActions({ campaign }: { campaign: Campaign }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Campaign Actions</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="flex items-center gap-2">
          <Badge variant={campaign.status === 'ACTIVE' ? 'default' : 'secondary'}>
            {campaign.status}
          </Badge>
        </div>
        <div className="flex gap-2">
          <Button variant="default">Edit Campaign</Button>
          <Button variant="outline">View Details</Button>
        </div>
      </CardContent>
    </Card>
  );
}
```

## Form Components

### Advanced Form Pattern with React Hook Form
Use the Form component wrapper for consistent form handling:

```typescript
// components/campaign/create-form.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import {
  Button,
  Input,
  Textarea,
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from '@/components/ui';

const campaignSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  description: z.string().min(1, 'Description is required'),
  fundingGoal: z.string().regex(/^\d+(\.\d+)?$/, 'Invalid amount'),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
});

type CampaignFormData = z.infer<typeof campaignSchema>;

interface CampaignCreateFormProps {
  onSubmit: (data: CampaignFormData) => Promise<void>;
  isLoading?: boolean;
  onDeveloperSubmit?: () => void;
}

export function CampaignCreateForm({ 
  onSubmit, 
  isLoading,
  onDeveloperSubmit 
}: CampaignCreateFormProps) {
  const form = useForm<CampaignFormData>({
    resolver: zodResolver(campaignSchema),
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Title</FormLabel>
              <FormControl>
                <Input
                  placeholder="My Campaign"
                  {...field}
                  onDoubleClick={onDeveloperSubmit}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Describe your campaign..."
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="fundingGoal"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Funding Goal</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  step="0.01"
                  placeholder="1000"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={isLoading}>
          {isLoading ? 'Creating...' : 'Create Campaign'}
        </Button>
      </form>
    </Form>
  );
}
```

### Form Submission with TanStack Query
Use mutation functions for form submissions instead of direct API calls:

```typescript
// components/campaign/update-form.tsx
import { useCampaignUpdate } from '@/lib/hooks';
import { Button, Input, Textarea, Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui';

export function CampaignUpdateForm({ campaign }: { campaign: Campaign }) {
  const { mutate: updateCampaign, isPending, error } = useCampaignUpdate();

  const handleSubmit = (data: CampaignFormData) => {
    updateCampaign({
      id: campaign.id,
      ...data,
    });
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
        {/* Form fields */}
        
        <Button type="submit" disabled={isPending}>
          {isPending ? 'Updating...' : 'Update Campaign'}
        </Button>
        
        {error && (
          <div className="text-sm text-destructive">{error.message}</div>
        )}
      </form>
    </Form>
  );
}
```

## Loading and Error States

### Loading Components
```typescript
// components/ui/loading.tsx
import { Loader2 } from 'lucide-react';

export function LoadingSpinner({ className }: { className?: string }) {
  return (
    <Loader2 className={cn('h-4 w-4 animate-spin', className)} />
  );
}

export function LoadingCard() {
  return (
    <div className="animate-pulse">
      <div className="h-48 bg-muted rounded-lg mb-4"></div>
      <div className="h-4 bg-muted rounded mb-2"></div>
      <div className="h-4 bg-muted rounded w-3/4"></div>
    </div>
  );
}
```

### Error Boundaries
```typescript
// components/error-boundary.tsx
'use client';

import { Component, type ReactNode } from 'react';
import { Button } from '@/components/ui';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        this.props.fallback || (
          <div className="text-center py-8">
            <h2 className="text-lg font-semibold mb-2">Something went wrong</h2>
            <p className="text-muted-foreground mb-4">
              {this.state.error?.message || 'An unexpected error occurred'}
            </p>
            <Button onClick={() => this.setState({ hasError: false })}>
              Try again
            </Button>
          </div>
        )
      );
    }

    return this.props.children;
  }
}
```

## Data Fetching Components

### Using Custom Hooks Pattern
Decouple data fetching logic from components using custom hooks from `@/lib/hooks`:

```typescript
// components/campaign/campaign-list.tsx
import { useCampaignList } from '@/lib/hooks';
import { CampaignCard } from './campaign-card';
import { LoadingCard } from '@/components/ui/loading';

export function CampaignList() {
  const { campaigns, isLoading, error } = useCampaignList();

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {Array.from({ length: 6 }).map((_, i) => (
          <LoadingCard key={i} />
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-8">
        <p className="text-destructive">Failed to load campaigns</p>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {campaigns?.map((campaign) => (
        <CampaignCard key={campaign.id} campaign={campaign} />
      ))}
    </div>
  );
}
```

The corresponding hook implementation should be in `@/lib/hooks`:

```typescript
// lib/hooks/useCampaignList.ts
import { useQuery } from '@tanstack/react-query';
import { getCampaigns } from '@/lib/api/campaigns';

export function useCampaignList() {
  const { data: campaigns, isLoading, error } = useQuery({
    queryKey: ['campaigns'],
    queryFn: getCampaigns,
  });

  return {
    campaigns,
    isLoading,
    error,
  };
}
```

## Modal and Dialog Components

### Dialog Usage
```typescript
// components/campaign/create-dialog.tsx
import { useState } from 'react';
import { useCampaignCreate } from '@/lib/hooks';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  Button,
} from '@/components/ui';
import { CampaignCreateForm } from './create-form';

export function CampaignCreateDialog() {
  const [open, setOpen] = useState(false);
  const { mutate: createCampaign } = useCampaignCreate();

  const handleSubmit = (data: CampaignFormData) => {
    createCampaign(data, {
      onSuccess: () => {
        setOpen(false);
      },
    });
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button>Create Campaign</Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Create New Campaign</DialogTitle>
        </DialogHeader>
        <CampaignCreateForm onSubmit={handleSubmit} />
      </DialogContent>
    </Dialog>
  );
}
```

## Accessibility Best Practices

### ARIA Attributes
- Use proper ARIA labels and descriptions
- Implement keyboard navigation
- Ensure proper focus management
- Use semantic HTML elements

### Screen Reader Support
```typescript
// components/campaign/campaign-stats.tsx
export function CampaignStats({ campaign }: { campaign: Campaign }) {
  return (
    <div className="grid grid-cols-2 gap-4">
      <div>
        <dt className="text-sm font-medium text-muted-foreground">
          Funding Goal
        </dt>
        <dd className="text-2xl font-bold" aria-label={`Goal: ${campaign.fundingGoal} ETH`}>
          {campaign.fundingGoal} ETH
        </dd>
      </div>
      <div>
        <dt className="text-sm font-medium text-muted-foreground">
          Amount Raised
        </dt>
        <dd className="text-2xl font-bold" aria-label={`Raised: ${campaign.amountRaised} ETH`}>
          {campaign.amountRaised} ETH
        </dd>
      </div>
    </div>
  );
}
```

## Performance Optimization

### Modern Optimization Patterns
With React Compiler, manual memoization is largely unnecessary as it automatically applies optimization equivalent to `memo` to all components. Focus on these patterns instead:

```typescript
// Use useMemo for expensive calculations
const expensiveValue = useMemo(() => {
  return heavyCalculation(data);
}, [data]);

// Use useCallback for stable function references
const handleClick = useCallback((id: string) => {
  onItemClick(id);
}, [onItemClick]);
```

### Lazy Loading - Use Sparingly
Only use lazy loading for components that are:
1. Large bundles (>100KB)
2. Rarely accessed
3. Complex charts/visualizations
4. Heavy third-party libraries

Always document the justification:

```typescript
// components/campaign/campaign-analytics.tsx
import { lazy, Suspense } from 'react';
import { LoadingSpinner } from '@/components/ui/loading';

/**
 * Lazy loaded because:
 * - Chart.js bundle is 200KB+
 * - Analytics only viewed by campaign creators
 * - Heavy computation for data processing
 */
const CampaignChart = lazy(() => import('./campaign-chart'));

export function CampaignAnalytics({ campaign }: { campaign: Campaign }) {
  return (
    <div>
      <h2>Campaign Analytics</h2>
      <Suspense fallback={<LoadingSpinner />}>
        <CampaignChart campaignId={campaign.id} />
      </Suspense>
    </div>
  );
}
```

## Best Practices Summary

### Component Organization
1. **Single UI import**: Use `import { Button, Input } from '@/components/ui'`
2. **Custom hooks**: Keep data fetching logic in `@/lib/hooks`
3. **Advanced forms**: Use Form wrapper with FormField components
4. **Mutation functions**: Use TanStack Query mutations for data changes

### Performance
1. **Let React Compiler handle memoization**
2. **Use useMemo/useCallback for expensive operations**
3. **Lazy load only when justified and documented**
4. **Implement proper loading and error states**

### Architecture
1. **Decouple data fetching from components**
2. **Use mutation functions instead of direct API calls**
3. **Avoid server actions** - prefer TanStack Query pattern
4. **Keep components focused on presentation**

