---
description: |
  Guidelines and patterns for structuring API routes and server actions in Next.js projects.
globs: []
alwaysApply: true
---

# API Patterns and Server Actions

## Next.js API Routes Structure

### Route Organization
- API routes are located in [app/api/](mdc:app/api/)
- Follow RESTful conventions where applicable
- Use route groups for logical organization
- Implement proper HTTP methods (GET, POST, PUT, DELETE)

### Required Imports
```typescript
// Standard imports for all API routes
import { ApiNotFoundError } from '@/lib/api/error';
import { response, handleError } from '@/lib/api/response';
import { checkAuth } from '@/lib/api/auth';
import { db } from '@/server/db';

// Import specific parameter types from /lib/api/types
import { CampaignsWithIdParams } from '@/lib/api/types';
```

### Route File Structure
```typescript
// app/api/campaigns/route.ts
import { ApiParameterError } from '@/lib/api/error';
import { response, handleError } from '@/lib/api/response';
import { checkAuth } from '@/lib/api/auth';
import { db } from '@/server/db';
import { z } from 'zod';

const createCampaignSchema = z.object({
  title: z.string().min(1),
  description: z.string().min(1),
  fundingGoal: z.string(),
  // ... other fields
});

export async function GET(req: Request) {
  try {
    // For public endpoints, explain why no auth is needed and DDoS prevention
    // This is a public endpoint for browsing campaigns with pagination limits
    // DDoS prevention: pageSize limited to 10, rate limiting in middleware
    
    const { searchParams } = new URL(req.url);
    const pageSize = parseInt(searchParams.get('pageSize') || '10');
    
    if (pageSize > 10) {
      throw new ApiParameterError('Maximum Page size exceeded');
    }
    
    const campaigns = await db.campaign.findMany({
      where: { status: 'ACTIVE' },
      include: { images: true },
      take: pageSize
    });
    
    return response(campaigns);
  } catch (error: unknown) {
    return handleError(error);
  }
}

export async function POST(req: Request) {
  try {
    const session = await checkAuth(['user']);
    
    const body = await req.json();
    const validatedData = createCampaignSchema.parse(body);
    
    const campaign = await db.campaign.create({
      data: {
        ...validatedData,
        creatorAddress: session.user.address,
      }
    });
    
    return response(campaign);
  } catch (error: unknown) {
    return handleError(error);
  }
}
```

### Dynamic Routes
```typescript
// app/api/campaigns/[campaignId]/route.ts
import { ApiNotFoundError } from '@/lib/api/error';
import { response, handleError } from '@/lib/api/response';
import { CampaignsWithIdParams } from '@/lib/api/types';
import { db } from '@/server/db';

export async function GET(req: Request, { params }: CampaignsWithIdParams) {
  try {
    // Public endpoint - campaign details are publicly viewable
    // DDoS prevention: Database query optimization, caching headers
    
    const { campaignId } = await params;
    
    const campaign = await db.campaign.findUnique({
      where: { id: parseInt(campaignId) },
      include: {
        images: true,
        payments: true,
        comments: true,
      }
    });
    
    if (!campaign) {
      throw new ApiNotFoundError('Campaign not found');
    }
    
    return response({ campaign });
  } catch (error: unknown) {
    return handleError(error);
  }
}

export async function PATCH(req: Request, { params }: CampaignsWithIdParams) {
  try {
    const session = await checkAuth(['user']);
    const { campaignId } = await params;
    const body = await req.json();
    
    // Check ownership
    const campaign = await db.campaign.findUnique({
      where: { id: parseInt(campaignId) }
    });
    
    if (!campaign) {
      throw new ApiNotFoundError('Campaign not found');
    }
    
    if (campaign.creatorAddress !== session.user.address) {
      throw new ApiAuthNotAllowed('Not authorized to edit this campaign');
    }
    
    const updatedCampaign = await db.campaign.update({
      where: { id: parseInt(campaignId) },
      data: body
    });
    
    return response({ campaign: updatedCampaign });
  } catch (error: unknown) {
    return handleError(error);
  }
}
```

## Form Handling

### Client-Side Form Submission to API Routes
Instead of server actions, use client-side form handling with API routes for proper security:

```typescript
// components/campaign/update-form.tsx
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';

interface CampaignUpdateFormProps {
  campaign: Campaign;
  onSuccess?: () => void;
}

export function CampaignUpdateForm({ campaign, onSuccess }: CampaignUpdateFormProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(e.currentTarget);
    const data = {
      title: formData.get('title') as string,
      description: formData.get('description') as string,
      status: formData.get('status') as string,
    };

    try {
      const response = await fetch(`/api/campaigns/${campaign.id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update campaign');
      }

      onSuccess?.();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="title">Title</label>
        <Input
          id="title"
          name="title"
          defaultValue={campaign.title}
          required
        />
      </div>

      <div>
        <label htmlFor="description">Description</label>
        <Textarea
          id="description"
          name="description"
          defaultValue={campaign.description}
          required
        />
      </div>

      <div>
        <label htmlFor="status">Status</label>
        <select id="status" name="status" defaultValue={campaign.status}>
          <option value="DRAFT">Draft</option>
          <option value="ACTIVE">Active</option>
          <option value="COMPLETED">Completed</option>
        </select>
      </div>

      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Updating...' : 'Update Campaign'}
      </Button>

      {error && <p className="text-red-500">{error}</p>}
    </form>
  );
}
```

### Why API Routes Over Server Actions

1. **Security**: API routes use `checkAuth()` for proper session validation
2. **Consistency**: All data mutations go through the same authentication flow
3. **Error Handling**: Centralized error handling with proper HTTP status codes
4. **Testing**: API routes are easier to test in isolation
5. **Debugging**: Clear separation of concerns and easier to debug

## Authentication and Authorization

### Route Protection Patterns
```typescript
// Always use checkAuth for protected routes
export async function POST(req: Request) {
  try {
    const session = await checkAuth(['user']); // for regular users
    // or
    const session = await checkAuth(['admin']); // for admin-only routes
    
    // Route implementation
  } catch (error: unknown) {
    return handleError(error);
  }
}
```

### Public Endpoint Guidelines
For public endpoints that don't require authentication, always include:

1. **Clear comment explaining why it's public**
2. **DDoS prevention measures**

```typescript
export async function GET(req: Request) {
  try {
    // Public endpoint - campaign browsing is publicly available
    // DDoS prevention: pagination limits, rate limiting in middleware
    
    const { searchParams } = new URL(req.url);
    const pageSize = parseInt(searchParams.get('pageSize') || '10');
    
    if (pageSize > 10) {
      throw new ApiParameterError('Maximum Page size exceeded');
    }
    
    // Implementation
  } catch (error: unknown) {
    return handleError(error);
  }
}
```

### Role-Based Access Control
```typescript
import { checkAuth } from '@/lib/api/auth';
import { ApiAuthNotAllowed } from '@/lib/api/error';

// Different role requirements
const userSession = await checkAuth(['user']);
const adminSession = await checkAuth(['admin']);

// Custom permission checks
if (resource.ownerId !== session.user.address) {
  throw new ApiAuthNotAllowed('Not authorized to access this resource');
}
```

## Error Handling

### Available Error Types
```typescript
// Import from @/lib/api/error
import {
  ApiAuthError,           // 401 - Authentication required
  ApiAuthNotAllowed,      // 403 - Insufficient permissions
  ApiParameterError,      // 400 - Invalid parameters
  ApiNotFoundError,       // 404 - Resource not found
  ApiIntegrityError,      // 500 - Data integrity failure
  ApiConflictError,       // 409 - Data conflict
  ApiUpstreamError,       // 503 - External service failure
} from '@/lib/api/error';
```

### Error Handling Pattern
```typescript
export async function POST(req: Request) {
  try {
    const session = await checkAuth(['user']);
    
    const body = await req.json();
    if (!body.requiredField) {
      throw new ApiParameterError('Missing required field');
    }
    
    const resource = await db.resource.findUnique({
      where: { id: body.id }
    });
    
    if (!resource) {
      throw new ApiNotFoundError('Resource not found');
    }
    
    if (resource.ownerId !== session.user.address) {
      throw new ApiAuthNotAllowed('Not authorized');
    }
    
    return response({ success: true });
  } catch (error: unknown) {
    return handleError(error); // Centralized error handling
  }
}
```

## Data Validation

### Input Validation with Zod
```typescript
import { z } from 'zod';
import { ApiParameterError } from '@/lib/api/error';

const campaignSchema = z.object({
  title: z.string().min(1, 'Title is required').max(100),
  description: z.string().min(1, 'Description is required'),
  fundingGoal: z.string().regex(/^\d+(\.\d+)?$/, 'Invalid funding goal'),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
  location: z.string().optional(),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validatedData = campaignSchema.parse(body);
    
    // Use validatedData
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      throw new ApiParameterError('Invalid input', error.errors);
    }
    return handleError(error);
  }
}
```

## Response Formatting

### Response Patterns
```typescript
import { response, handleError } from '@/lib/api/response';

// Success responses
return response({ campaign }); // Single object
return response(campaigns); // Array
return response({ success: true, data: result }); // Structured response

// Error handling is automatic through handleError
catch (error: unknown) {
  return handleError(error);
}
```

### API Response Structure
The `response` utility automatically wraps data in JSON with 200 status.
The `handleError` utility provides consistent error formatting:

```typescript
// Success response
{
  "campaign": { ... }
}

// Error response
{
  "success": false,
  "error": "ApplicationError, invalid parameters: Missing required field",
  "details": [...]
}
```

## Rate Limiting and Security

### DDoS Prevention for Public Endpoints
```typescript
// Pagination limits
const pageSize = parseInt(searchParams.get('pageSize') || '10');
if (pageSize > 10) {
  throw new ApiParameterError('Maximum Page size exceeded');
}

// Query optimization
const campaigns = await db.campaign.findMany({
  where: { status: 'ACTIVE' },
  take: pageSize,
  select: {
    id: true,
    title: true,
    description: true,
    // Only select needed fields
  }
});
```

### Input Sanitization
```typescript
// Use Zod schemas for validation
const sanitizedData = schema.parse(rawInput);

// Additional sanitization if needed
const sanitizedTitle = title.trim().substring(0, 100);
```

## Type Definitions

### Parameter Types
Define route parameter types in `/lib/api/types/`:

```typescript
// lib/api/types/campaigns/index.ts
export interface CampaignsWithIdParams {
  params: Promise<{
    campaignId: string;
  }>;
}

export interface PostCampaignsBody {
  title: string;
  description: string;
  fundingGoal: string;
}
```

### Usage in Routes
```typescript
import { CampaignsWithIdParams } from '@/lib/api/types';

export async function GET(req: Request, { params }: CampaignsWithIdParams) {
  const { campaignId } = await params;
  // ...
}
```

## Testing API Routes

### Mock Testing Structure
```typescript
// __tests__/api/campaigns.test.ts
import { GET, POST } from '@/app/api/campaigns/route';
import { checkAuth } from '@/lib/api/auth';
import { db } from '@/server/db';

jest.mock('@/lib/api/auth');
jest.mock('@/server/db');

describe('/api/campaigns', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return campaigns for GET request', async () => {
    (db.campaign.findMany as jest.Mock).mockResolvedValue([
      { id: 1, title: 'Test Campaign' }
    ]);

    const request = new Request('http://localhost/api/campaigns');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data).toHaveLength(1);
  });

  it('should create campaign for authenticated user', async () => {
    (checkAuth as jest.Mock).mockResolvedValue({
      user: { address: '0x123' }
    });
    
    (db.campaign.create as jest.Mock).mockResolvedValue({
      id: 1,
      title: 'New Campaign'
    });

    const request = new Request('http://localhost/api/campaigns', {
      method: 'POST',
      body: JSON.stringify({
        title: 'New Campaign',
        description: 'Test description',
        fundingGoal: '1000'
      })
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.title).toBe('New Campaign');
  });
});
```

## Best Practices Summary

### Required Structure
1. **Use `Request` not `NextRequest`**
2. **Import from `@/lib/api/error` for error classes**
3. **Import from `@/lib/api/response` for response utilities**
4. **Import from `@/lib/api/types` for parameter types**
5. **Use `checkAuth(['role'])` for authentication**
6. **Use `response()` and `handleError()` consistently**

### Public Endpoint Requirements
1. **Comment explaining why endpoint is public**
2. **Describe DDoS prevention measures**
3. **Implement pagination limits**
4. **Optimize database queries**

### Error Handling
1. **Use try/catch with `handleError(error)`**
2. **Throw appropriate error types**
3. **Add parameter validation with Zod**
4. **Handle edge cases explicitly**

### Security
1. **Always validate inputs**
2. **Check resource ownership**
3. **Use type-safe parameter extraction**
4. **Implement proper authorization checks**
5. **AVOID server actions** - Use API routes with client-side form handling instead

### Deprecated Patterns to Avoid
1. **Server Actions** - Not properly secured by session validation
2. **NextRequest/NextResponse** - Use `Request` and response utilities instead
3. **Manual auth checks** - Use `checkAuth(['role'])` consistently
