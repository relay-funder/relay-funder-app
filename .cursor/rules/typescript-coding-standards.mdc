---
description: |
  Enforces TypeScript coding standards for the Akashic project. All TypeScript code must use explicit types, leverage Zod for runtime validation, and follow project-specific patterns for API, component, and database code. Adhere to best practices for performance, security, accessibility, and testing as outlined in this rule file.
globs:
  - "**/*.ts"
  - "**/*.tsx"
alwaysApply: true
---

# TypeScript Coding Standards

## TypeScript Safety Guidelines

### Avoid `any` Type - Use Type-Safe Alternatives

**❌ Never use `any`** - it defeats the purpose of TypeScript's type safety:

```typescript
// ❌ BAD - Loses all type safety
function processData(data: any): any {
  return data.someProperty;
}

// ✅ GOOD - Use proper types
interface DataType {
  someProperty: string;
  optionalField?: number;
}

function processData(data: DataType): string {
  return data.someProperty;
}
```

### Type-Safe Alternatives to `any`

#### 1. Use `unknown` for Truly Unknown Data
```typescript
// ✅ Use unknown for data that needs runtime validation
function handleApiResponse(response: unknown) {
  // Must validate before use
  if (typeof response === 'object' && response !== null && 'data' in response) {
    return (response as { data: unknown }).data;
  }
  throw new Error('Invalid response format');
}

// ✅ Better: Use Zod for runtime validation
const responseSchema = z.object({
  data: z.unknown(),
  status: z.string(),
});

function handleApiResponse(response: unknown) {
  const parsed = responseSchema.parse(response);
  return parsed.data;
}
```

#### 2. Use Generic Types for Reusable Code
```typescript
// ✅ Use generics instead of any
interface ApiResponse<T> {
  data: T;
  status: string;
  error?: string;
}

function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  // Implementation with proper typing
}

// Usage with specific types
const userResponse = await fetchData<User>('/api/users');
const campaignResponse = await fetchData<Campaign>('/api/campaigns');
```

#### 3. Use Union Types for Multiple Possibilities
```typescript
// ✅ Use union types instead of any
type EventHandler = 
  | ((event: MouseEvent) => void)
  | ((event: KeyboardEvent) => void)
  | ((event: TouchEvent) => void);

// ✅ Use discriminated unions for complex types
type ApiResult = 
  | { success: true; data: Campaign }
  | { success: false; error: string };
```

#### 4. Use `Record` for Dynamic Object Keys
```typescript
// ✅ Use Record instead of any for objects with dynamic keys
type CampaignStats = Record<string, number>;

// ✅ Better: Use specific key types when possible
type CampaignMetrics = Record<'views' | 'donations' | 'shares', number>;
```

#### 5. Use Type Assertions Sparingly and Safely
```typescript
// ❌ BAD - Unsafe assertion
const data = response as any;

// ✅ GOOD - Safe assertion with validation
function isUser(obj: unknown): obj is User {
  return typeof obj === 'object' && 
         obj !== null && 
         'address' in obj && 
         typeof (obj as any).address === 'string';
}

if (isUser(response)) {
  // TypeScript knows response is User here
  const userAddress = response.address;
}
```

### Handling Third-Party Libraries Without Types
```typescript
// ✅ Create minimal type definitions
declare module 'untyped-library' {
  export function someFunction(param: string): string;
  export interface SomeInterface {
    property: number;
  }
}

// ✅ Use module augmentation for extending types
declare module '@existing/library' {
  interface ExistingInterface {
    newProperty: string;
  }
}
```

### Error Handling with Type Safety
```typescript
// ✅ Use proper error typing
class CustomError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number
  ) {
    super(message);
    this.name = 'CustomError';
  }
}

// ✅ Type-safe error handling
function handleError(error: unknown): string {
  if (error instanceof CustomError) {
    return `${error.code}: ${error.message}`;
  }
  
  if (error instanceof Error) {
    return error.message;
  }
  
  return 'An unknown error occurred';
}
```

## Code Style Guidelines

### Type Definitions
- Use explicit type annotations for function parameters and return types
- Prefer `interface` over `type` for object shapes
- Use `type` for unions, intersections, and computed types
- Export types from dedicated files in `/types` directory
- **Never use `any`** - use `unknown`, generics, or specific types instead

### Naming Conventions
- Use PascalCase for types, interfaces, and React components
- Use camelCase for variables, functions, and object properties
- Use UPPER_SNAKE_CASE for constants and environment variables
- Use descriptive, explicit variable names over abbreviations

### Import/Export Standards
- Use named imports/exports over default exports (except for React components)
- Group imports: external libraries, internal modules, relative imports
- Use absolute imports with `@/` prefix for internal modules
- Keep imports organized and remove unused imports

### React Component Standards
- Use function components with TypeScript
- Define component props with interfaces
- Use React.FC sparingly, prefer explicit function declarations
- Extract complex logic into custom hooks in `/lib/hooks`

### Error Handling
- Use proper error boundaries for React components
- Implement try-catch blocks for async operations
- Use Zod for runtime validation and type safety
- Handle edge cases explicitly
- Use `unknown` type for error parameters

### Database & API Standards
- Use Prisma types for database operations
- Define API response types in `/lib/api/types`
- Use API routes with client-side form handling (avoid server actions)
- Implement proper error handling for database operations

## File Organization

### Component Files
```typescript
// ComponentName.tsx
import { type ComponentProps } from 'react';

interface ComponentNameProps {
  // Props definition with explicit types
  title: string;
  onAction?: (id: string) => void;
  data: Campaign[]; // Never Campaign[] | any
}

export function ComponentName({ title, onAction, data }: ComponentNameProps) {
  // Component implementation with type safety
  const handleClick = (campaign: Campaign) => {
    onAction?.(campaign.id.toString());
  };

  return (
    <div>
      <h2>{title}</h2>
      {data.map(campaign => (
        <div key={campaign.id} onClick={() => handleClick(campaign)}>
          {campaign.title}
        </div>
      ))}
    </div>
  );
}
```

### API Route Files
```typescript
// route.ts
import { z } from 'zod';
import { ApiParameterError } from '@/lib/api/error';
import { response, handleError } from '@/lib/api/response';
import { checkAuth } from '@/lib/api/auth';

const requestSchema = z.object({
  title: z.string().min(1),
  description: z.string(),
  // Always use specific schemas, never z.any()
});

export async function POST(req: Request) {
  try {
    const session = await checkAuth(['user']);
    
    const body = await req.json();
    const validatedData = requestSchema.parse(body); // Type-safe validation
    
    // Implementation with proper typing
    return response({ success: true, data: validatedData });
  } catch (error: unknown) { // Use unknown, not any
    return handleError(error);
  }
}
```

### Type Definition Files
```typescript
// types/feature.ts
export interface FeatureType {
  id: string;
  name: string;
  status: FeatureStatus;
  metadata?: Record<string, string>; // Instead of Record<string, any>
}

export type FeatureStatus = 'active' | 'inactive' | 'pending';

// ✅ Use branded types for stronger typing
export type UserId = string & { readonly brand: unique symbol };
export type CampaignId = string & { readonly brand: unique symbol };
```

### Utility Functions with Type Safety
```typescript
// lib/utils/validation.ts
import { z } from 'zod';

// ✅ Type-safe utility functions
export function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== 'string') {
    throw new Error('Expected string');
  }
}

export function parseJson<T>(
  jsonString: string, 
  schema: z.ZodSchema<T>
): T {
  try {
    const parsed: unknown = JSON.parse(jsonString);
    return schema.parse(parsed);
  } catch (error) {
    throw new Error('Invalid JSON format');
  }
}

// Usage
const campaignSchema = z.object({
  title: z.string(),
  description: z.string(),
});

const campaign = parseJson(jsonResponse, campaignSchema);
// campaign is properly typed as { title: string; description: string }
```

## Best Practices

### Type Safety
1. **Never use `any`** - use `unknown`, generics, or specific types
2. **Use Zod for runtime validation** of external data
3. **Prefer type guards** over type assertions
4. **Use discriminated unions** for complex state management
5. **Enable strict TypeScript settings** in tsconfig.json

### Performance
- Let React Compiler handle optimization instead of manual memoization
- Implement proper loading states with typed data
- Use server components when possible
- Optimize database queries with proper includes

### Security
- Validate all user inputs with Zod schemas
- Use API routes for sensitive operations (avoid server actions)
- Implement proper authentication checks
- Sanitize data on retrieval with proper typing

### Accessibility
- Use semantic HTML elements
- Implement proper ARIA attributes with typed props
- Ensure keyboard navigation support
- Use Radix UI components for accessibility

### Testing
- Write unit tests for utility functions with proper typing
- Test React components with properly typed mocks
- Use TypeScript for test files
- Mock external dependencies with proper type definitions

## TypeScript Configuration

### Recommended tsconfig.json Settings
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

These settings help catch type safety issues at compile time and prevent `any` from creeping into the codebase.
