---
description: |
  Database patterns and Prisma guidelines for Akashic. 
  - Use the centralized db instance from server/db.ts for all database operations.
  - Never instantiate multiple Prisma clients.
  - Always validate input with Zod schemas before database writes.
  - Use descriptive migration names and review generated migrations before applying.
  - Prefer select/include for efficient queries and avoid N+1 problems.
  - Implement pagination for large datasets.
  - Enforce proper authorization and input sanitization for all queries.
  - Hash sensitive data and use environment variables for secrets.
  - Test migrations on staging before production and keep them atomic and reversible.
  - Handle Prisma errors explicitly and log for audit purposes.
  - Use connection pooling in production and monitor connection usage.
  - Reference main schema in prisma/schema.prisma.
globs:
  - prisma/schema.prisma
  - server/db.ts
  - lib/database.ts
  - app/api/**/*.ts
  - app/api/**/*.tsx
  - server/**/*.ts
  - server/**/*.tsx
alwaysApply: true
---

# Database Patterns and Prisma Guidelines

## Database Schema Reference
The main database schema is defined in [prisma/schema.prisma](mdc:prisma/schema.prisma) with the following key models:

### Core Models
- **Campaign**: Fundraising campaigns with status tracking
- **User**: User accounts with wallet addresses and roles
- **Payment**: Payment tracking for campaigns
- **Collection**: Curated campaign collections
- **Round**: Funding rounds with quadratic funding support
- **Comment**: Campaign comments and updates

### Key Relationships
- Campaigns have many Payments, Comments, Updates, and Images
- Users have many Payments and can be campaign creators
- Collections can contain many Campaigns
- Rounds can have many Recipients (campaigns)

## Prisma Client Usage

### Database Connection
- Use the centralized db instance from [server/db.ts](mdc:server/db.ts)
- Never create multiple Prisma client instances
- Import pattern: `import { db } from '@/server/db';`

### Query Patterns

#### Basic CRUD Operations
```typescript
// Create
const campaign = await db.campaign.create({
  data: {
    title: 'New Campaign',
    description: 'Campaign description',
    // ... other fields
  }
});

// Read with relations
const campaign = await db.campaign.findUnique({
  where: { slug: 'campaign-slug' },
  include: {
    images: true,
    payments: true,
    comments: true,
    updates: true,
  }
});

// Update
const updated = await db.campaign.update({
  where: { id: campaignId },
  data: { status: 'ACTIVE' }
});

// Delete (use soft delete when possible)
const deleted = await db.campaign.delete({
  where: { id: campaignId }
});
```

#### Complex Queries
```typescript
// Filtering and sorting
const campaigns = await db.campaign.findMany({
  where: {
    status: 'ACTIVE',
    endTime: { gt: new Date() }
  },
  orderBy: { createdAt: 'desc' },
  take: 10,
  skip: 0
});

// Aggregations
const stats = await db.payment.aggregate({
  where: { campaignId: id },
  _sum: { amount: true },
  _count: true
});
```

## Data Modeling Best Practices

### Field Naming
- Use camelCase for field names
- Use descriptive names (e.g., `creatorAddress` not `creator`)
- Include units in field names when relevant (e.g., `fundingGoal` for string amounts)

### Relationships
- Use explicit foreign key fields (e.g., `campaignId`, `userId`)
- Define proper cascade behaviors for deletions
- Use `@relation` attributes for complex relationships

### Enums
- Define enums for status fields and fixed value sets
- Use UPPER_SNAKE_CASE for enum values
- Keep enum values descriptive and future-proof

### Indexes
- Add indexes for frequently queried fields
- Use compound indexes for multi-field queries
- Consider unique constraints for business logic

## Migration Guidelines

### Migration Commands
Use the modern Docker Compose syntax with app-shell:

```bash
# Generate migration
docker compose run --rm app-shell /bin/sh -c 'pnpm prisma migrate dev --name migration_name'

# Deploy migrations
docker compose run --rm app-shell /bin/sh -c 'pnpm prisma migrate deploy'

# Reset database (development only)
docker compose run --rm app-shell /bin/sh -c 'pnpm prisma migrate reset'

# Generate Prisma client
docker compose run --rm app-shell /bin/sh -c 'pnpm prisma generate'
```

### Migration Best Practices
- Always review generated migrations before applying
- Use descriptive migration names
- Test migrations on staging before production
- Keep migrations atomic and reversible when possible

## Error Handling

### API Route Error Handling
Database errors are typically handled in API functions using the centralized error handling system. Most business logic should not directly handle Prisma errors:

```typescript
// In API routes - this is where Prisma errors are caught
export async function GET(req: Request) {
  try {
    const campaign = await db.campaign.findUnique({
      where: { id: campaignId }
    });
    
    if (!campaign) {
      throw new ApiNotFoundError('Campaign not found');
    }
    
    return response({ campaign });
  } catch (error: unknown) {
    return handleError(error); // Centralized error handling
  }
}
```

### Rare Business Logic Error Handling
Only handle Prisma errors directly in business logic when absolutely necessary:

```typescript
import { db } from '@/server/db'; // Correct import pattern

try {
  const result = await db.campaign.create({ data });
} catch (error) {
  // Handle specific business logic requirements
  if (error instanceof Error && error.message.includes('P2002')) {
    // Handle unique constraint violation in business logic
  }
}
```

## Data Validation and Sanitization

### Input Validation
- Use Zod schemas for input validation before database operations
- Validate business logic constraints
- Handle edge cases explicitly

### Data Sanitization
**Sanitize data on retrieval** to ensure all functions can assume valid data with TypeScript insurance:

```typescript
// Sanitize when reading from database
export async function getCampaignById(id: number) {
  const campaign = await db.campaign.findUnique({
    where: { id }
  });
  
  if (!campaign) {
    throw new ApiNotFoundError('Campaign not found');
  }
  
  // Sanitize on retrieval
  return {
    ...campaign,
    title: campaign.title.trim(),
    description: sanitizeHtml(campaign.description),
    // All downstream functions can assume clean data
  };
}
```

### Security Considerations

#### Data Access
- Implement proper authorization checks in API routes
- Validate all user inputs with Zod schemas
- Use parameterized queries (Prisma handles this automatically)

#### Best Practices
- Hash passwords and sensitive information
- Use environment variables for secrets
- Implement proper audit logging
- Consider data encryption for PII

## Performance Considerations

### Query Optimization
- Use `include` judiciously to avoid N+1 queries
- Implement pagination for large datasets
- Use database-level filtering over application-level filtering
- Only use `select` for fields that significantly impact performance (large JSON fields)

## Common Patterns

### User-Owned Resources
```typescript
// Check ownership in API routes
const campaign = await db.campaign.findUnique({
  where: { id: campaignId }
});

if (!campaign || campaign.creatorAddress !== session.user.address) {
  throw new ApiAuthNotAllowed('Not authorized to access this campaign');
}
```

### Pagination
```typescript
// Standard pagination pattern
const campaigns = await db.campaign.findMany({
  where: { status: 'ACTIVE' },
  orderBy: { createdAt: 'desc' },
  take: pageSize,
  skip: (page - 1) * pageSize,
});
```

### Aggregations
```typescript
// Get campaign statistics
const campaignStats = await db.payment.aggregate({
  where: { campaignId: id },
  _sum: { amount: true },
  _count: true,
  _avg: { amount: true },
});
```

## Best Practices Summary

### Import and Connection
1. **Always use**: `import { db } from '@/server/db'`
2. **Never create multiple Prisma client instances**
3. **Use centralized database connection**

### Error Handling
1. **Handle Prisma errors in API routes** with centralized error handling
2. **Rarely handle Prisma errors in business logic** - only when specifically needed
3. **Use proper error types** from `@/lib/api/error`

### Data Management
1. **Sanitize data on retrieval** for TypeScript insurance
2. **Validate inputs with Zod** before database operations
3. **Use descriptive field names** and proper relationships
4. **Implement proper authorization checks** in API routes

### Performance
1. **Use `include` carefully** to avoid N+1 queries
2. **Implement pagination** for large datasets
3. **Only use `select` when performance-critical** (large JSON fields)
4. **Prefer database-level filtering** over application filtering
