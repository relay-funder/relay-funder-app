# CC Protocol Contract Tooling Generation Rules

These rules govern the generation of contract interaction tooling for CC Protocol integration, specifically focusing on KeepWhatsRaised treasury testing and deployment workflows.

## Core Principles

1. **Simplified Flow**: Focus on essential functions only - avoid unnecessary registration/approval steps
2. **Timing Precision**: Campaign timing must be calculated correctly to prevent silent reverts
3. **Test-Driven**: Generate tooling that validates complete workflows end-to-end
4. **Documentation Authority**: Follow keep-whats-raised-treasury.md as the authoritative source

## KeepWhatsRaised Treasury Workflow

### Essential Functions Only
The complete test flow requires only these 4 core functions:

1. **`createCampaign`** - Deploy CampaignInfo contract
2. **`deploy`** - Deploy KeepWhatsRaised treasury instance  
3. **`configureTreasury`** - Set operational parameters
4. **`approveWithdrawal`** - Enable withdrawal functionality

### Functions NOT Required for Basic Testing
- `registerTreasuryImplementation` - Implementation should be pre-registered
- `approveTreasuryImplementation` - Implementation should be pre-approved
- `enlistPlatform` - Platform should be pre-enlisted
- `addPlatformData` - Platform data should be pre-configured

## Critical Timing Requirements

### Campaign Creation Timing
When generating `createCampaign` calls, timing parameters are critical:

```bash
# ✅ CORRECT - Future startTime prevents silent reverts
local launch_time=$(($(date +%s) + 60))    # 60 seconds from now
local deadline=$((launch_time + 1209600))  # 2 weeks after launch (14 * 24 * 60 * 60)

# ❌ INCORRECT - Past or immediate startTime causes silent failures
local launch_time=$(date +%s)              # Current time
local launch_time=$(($(date +%s) - 3600))  # Past time
```

### Timing Validation Rules
- **startTime**: Must be at least 30-60 seconds in the future
- **deadline**: Must be after startTime (minimum 1 day recommended)
- **Buffer Time**: Always add buffer time to account for transaction processing delays

## Contract Parameter Patterns

### CampaignInfo Creation Parameters
```bash
# Generate unique campaign parameters
local timestamp=$(date +%s)
local identifier_hash="0x$(echo -n "test-campaign-${timestamp}" | openssl dgst -sha256 | cut -d' ' -f2)"
local launch_time=$(($(date +%s) + 60))    # 60 seconds from now
local deadline=$((launch_time + 1209600))  # 2 weeks after launch
local goal_amount="1000000000000000000000" # 1000 USDC (18 decimals)

# Cast command for campaign creation
cast send $NEXT_PUBLIC_CAMPAIGN_INFO_FACTORY \
    "createCampaign(address,bytes32,bytes32[],bytes32[],bytes32[],(uint256,uint256,uint256))" \
    $NEXT_PUBLIC_PLATFORM_ADMIN \
    $identifier_hash \
    "$NEXT_PUBLIC_PLATFORM_HASH" \
    "" \
    "" \
    "($launch_time,$deadline,$goal_amount)"
```

### Treasury Deployment Parameters
```bash
# Treasury deployment using extracted campaign address
cast send $NEXT_PUBLIC_TREASURY_FACTORY \
    "deploy(bytes32,address,uint256,string,string)" \
    $NEXT_PUBLIC_PLATFORM_HASH \
    $campaign_address \
    0 \
    "Campaign Treasury" \
    "CAMPT"
```

### Treasury Configuration Parameters
```bash
# Configuration values in shell variables
local min_withdrawal="50000000000000000000000"  # 50k tokens
local withdrawal_delay=$((7 * 24 * 60 * 60))    # 7 days in seconds
local refund_delay=$((14 * 24 * 60 * 60))       # 14 days in seconds
local config_lock=$((2 * 24 * 60 * 60))         # 2 days in seconds
local is_colombian=false

# Fee structure keys (from documentation)
local flat_fee_key="0x0000000000000000000000000000000000000000000000000000000000000000"
local cumulative_fee_key="0x0000000000000000000000000000000000000000000000000000000000000000"
local percentage_fee_key="0x0000000000000000000000000000000000000000000000000000000000000000"
```

## Error Prevention Patterns

### Silent Revert Prevention
- **Always validate timing**: Check that startTime > currentTime + buffer
- **Verify addresses**: Ensure all contract addresses have deployed code
- **Check permissions**: Validate caller has required admin permissions
- **Gas estimation**: Use adequate gas limits for complex operations

### Transaction Hash Extraction
When generating tooling for transaction monitoring:

```bash
# ✅ CORRECT - Robust transaction hash extraction
local tx_hash=$(echo "$result" | grep "transactionHash" | awk '{print $2}' | head -1)
if [[ ! "$tx_hash" =~ ^0x[a-fA-F0-9]{64}$ ]]; then
  tx_hash=$(echo "$result" | grep -o '0x[a-fA-F0-9]\{64\}' | tail -1)
fi

# ❌ INCORRECT - Fragile extraction
local tx_hash=$(echo "$result" | grep "transactionHash")
```

## Testing Workflow Generation

### Complete Test Sequence
When generating test tooling, follow this exact sequence:

1. **Environment Setup**
   - Load environment variables
   - Verify RPC connectivity
   - Check admin wallet balances
   - Validate contract addresses

2. **Campaign Creation**
   - Calculate proper timing (startTime = now + 60s)
   - Generate unique identifier hash
   - Deploy CampaignInfo contract
   - Extract campaign address from transaction logs

3. **Treasury Deployment**
   - Use extracted campaign address
   - Deploy with implementation ID 0 (KeepWhatsRaised)
   - Extract treasury address from transaction logs

4. **Treasury Configuration**
   - Configure operational parameters
   - Set fee structure keys
   - Validate configuration success

5. **Withdrawal Approval**
   - Enable withdrawal functionality
   - Confirm approval status

6. **Validation Testing**
   - Test treasury read functions
   - Verify campaign timing
   - Check balance queries
   - Validate pledge patterns

## Documentation Integration

### Authority Hierarchy
1. **Primary**: keep-whats-raised-treasury.md - authoritative technical specification
2. **Secondary**: cc-protocol-test.sh - implementation reference (may contain outdated patterns)
3. **Context**: Contract ABI files and deployment addresses

### When Documentation Conflicts
- **Always prioritize** keep-whats-raised-treasury.md over shell script patterns
- **Flag conflicts** for human review when generating tooling
- **Document assumptions** when making implementation choices

## Code Generation Standards

### Function Call Patterns
```bash
# ✅ Generate with proper error handling
execute_campaign_creation() {
    local result=$(cast send $NEXT_PUBLIC_CAMPAIGN_INFO_FACTORY \
        "createCampaign(...)" \
        --private-key $PLATFORM_ADMIN_PRIVATE_KEY \
        --rpc-url $NEXT_PUBLIC_RPC_URL \
        --gas-limit 3000000 2>&1)
    
    # Extract transaction hash with validation
    local tx_hash=$(echo "$result" | grep "transactionHash" | awk '{print $2}' | head -1)
    if [[ ! "$tx_hash" =~ ^0x[a-fA-F0-9]{64}$ ]]; then
        tx_hash=$(echo "$result" | grep -o '0x[a-fA-F0-9]\{64\}' | tail -1)
    fi
    
    if [[ ! "$tx_hash" =~ ^0x[a-fA-F0-9]{64}$ ]]; then
        echo "ERROR: Campaign creation failed"
        echo "Result: $result"
        return 1
    fi
    
    echo "SUCCESS: Campaign created with TX: $tx_hash"
    export CAMPAIGN_TX_HASH="$tx_hash"
    return 0
}

# ❌ Avoid bare function calls without error handling
cast send $contract "function(...)" --private-key $key
```

### Timing Calculation Utilities
Always generate timing utilities that account for network delays:

```bash
# Calculate proper campaign timing with buffer
calculate_campaign_timing() {
    local now=$(date +%s)
    local launch_time=$((now + 60))        # 60 second buffer
    local deadline=$((launch_time + 1209600))  # 2 weeks (14 * 24 * 60 * 60)
    
    echo "Launch Time: $launch_time ($(date -r $launch_time))"
    echo "Deadline: $deadline ($(date -r $deadline))"
    
    export CAMPAIGN_LAUNCH_TIME="$launch_time"
    export CAMPAIGN_DEADLINE="$deadline"
}
```

## Integration with Akashic Application

### Database Schema Alignment
When generating tooling for Akashic integration:

- **campaignAddress**: Store CampaignInfo contract address
- **cryptoTreasuryAddress**: Store KeepWhatsRaised treasury address
- **treasuryMode**: Set to "CRYPTO_ONLY" for KWR-only deployments

### API Route Integration
Generate tooling that aligns with existing API patterns:

```bash
# Campaign creation workflow - called from API
create_campaign_workflow() {
    local campaign_id="$1"
    
    # Step 1: Calculate timing
    calculate_campaign_timing
    
    # Step 2: Deploy CampaignInfo
    execute_campaign_creation
    
    # Step 3: Extract and store campaign address
    extract_campaign_address_from_tx "$CAMPAIGN_TX_HASH"
    
    # Step 4: Update database with campaignAddress
    echo "Store campaignAddress: $EXTRACTED_CAMPAIGN_ADDRESS for campaign $campaign_id"
}

# Admin approval workflow - called from API
approve_campaign_workflow() {
    local campaign_id="$1"
    local campaign_address="$2"
    
    # Step 1: Deploy treasury
    deploy_treasury "$campaign_address"
    
    # Step 2: Configure treasury
    configure_treasury "$TREASURY_ADDRESS"
    
    # Step 3: Approve withdrawal
    approve_withdrawal "$TREASURY_ADDRESS"
    
    # Step 4: Update database with cryptoTreasuryAddress
    echo "Store cryptoTreasuryAddress: $TREASURY_ADDRESS for campaign $campaign_id"
}
```

---
*These rules ensure reliable and consistent CC Protocol contract tooling generation*
description:
globs:
alwaysApply: false
---
